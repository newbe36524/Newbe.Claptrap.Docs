---
title: 'Режим Actor'
description: 'Режим Actor'
---

Режим Actor — это модель однофайлового программирования.Применение этой модели программирования может решить некоторые проблемы симулирования системы очень хорошо.Проблема совместного доступа, упомянутая здесь, относится к проблеме, когда компьютер логически обрабатывает один и тот же данный, что может привести к неверным данным из-за нескольких однофайлных запросов.Эта проблема, безусловно, столкнется с многопоточным программированием.В качестве простого примера, если вы используете 100 потоков одновременно для выполнения операции ++ к переменной int в памяти без блокировки синхронизации.Тогда конечный результат этой переменной, как правило, меньше 100.Вот как режим Actor избегает этой проблемы.

Во-первых, для удобства читателя можно считать Actor объектом здесь.В объектно-ориентированных языках (Java, C# и т. д.) Actor считается объектом, созданным``new и ключевыми словами.Тем не менее, этот объект имеет некоторые особенности：

**имеет собственное состояние**.Объекты могут иметь свои собственные свойства, которые являются основными функциями объектно-ориентированного языка.В режиме Actor эти свойства в совокупности называются состояниями Actor.Состояние Actor поддерживается самим Actor.

Это подчеркивает два момента：

Во-первых, состояние Actor может быть изменено только самими себеи, а для изменения состояния Actor извне его можно изменить только путем вызова Actor.

![Обновите состояние Acactor](/images/20190226-001.gif)

Во-вторых, состояние Actor поддерживается только внутри Actor и не является общим для любого объекта, кроме текущего Actor.Несвяжее значение здесь также подчеркивает, что он не может привести к изменению внутреннего состояния Actor путем изменения внешнего свойства.Это в первую очередь для того, чтобы отличаться от некоторых языков программирования, которые имеют характеристики языка "ссылки на объекты".Например,：свойство`public`на языке C#`class`, если это ссылочный тип, может`изменить свойство в<code>class`после получения этого класса</code>извне.Но это не допускается в режиме Actor.

![Общий доступ к состоянию Acactor](/images/20190226-003.gif)

Однако чтение данных изнутри Actor во внешний файл по-прежнему допустимо.

![Чтение состояния Acactor](/images/20190226-002.gif)

**однопоточный**.Actor обычно может принимать только один вызов в то же время.Потоки, описанные здесь, не совсем относятся к потокам на компьютере и используются для выделения терминов, используемых "Actor может обрабатывать только один запрошенный атрибут в то же время".Если actor в настоящее время принимает вызов, оставшиеся вызовы блокируются до тех пор, пока вызов не будет завершен, прежде чем следующий запрос будет разрешен.На самом деле это похоже на механизм блокировки синхронизации.Этот механизм позволяет избежать возможности проблемы слаженности при изменении внутреннего состояния Actor.В частности,：Если вы используете 100 потоков для однофайлового вызова Actor, попросите Actor выполнить операцию`++`на переменной`int`в состоянии.В конечном счете значение этого состояния должно быть 100.

![Вызов Actor в то же время](/images/20190226-004.gif)

Однако однопоточность также не является абсолютной, и однофайловая обработка разрешена без запроса на проблему однофайлового выполнения.Например, чтение состояния в Actor, который обычно не имеет проблемы с вхождами, позволяет операции симулы на этом этапе.

![Чтение Actor в то же время](/images/20190226-005.gif)
