---
title: "Режим Actor"
description: "Режим Actor"
---

Режим Actor — это модель однофайлового программирования.Применение этой модели программирования может решить некоторые проблемы симулирования системы очень хорошо.Проблема совместного доступа, упомянутая здесь, относится к проблеме, когда компьютер логически обрабатывает один и тот же данный, что может привести к неверным данным из-за нескольких однофайлных запросов.Эта проблема, безусловно, столкнется с многопоточным программированием.В качестве простого примера, если вы используете 100 потоков одновременно для выполнения операции ++ к переменной int в памяти без блокировки синхронизации.Тогда конечный результат этой переменной, как правило, меньше 100.Вот как режим Actor избегает этой проблемы.

Во-первых, для удобства читателя можно считать Actor объектом здесь.在面向对象的语言（Java、C#等）当中，可以认为 Actor 就是通过 new 关键词创建出来的对象。Тем не менее, этот объект имеет некоторые особенности：

**имеет собственное состояние**.Объекты могут иметь свои собственные свойства, которые являются основными функциями объектно-ориентированного языка.在 Actor 模式中，这些属性都被统称为 Actor 的状态（State） 。Состояние Actor поддерживается самим Actor.

Это подчеркивает два момента：

Во-первых, состояние Actor может быть изменено только самими себеи, а для изменения состояния Actor извне его можно изменить только путем вызова Actor.

![Обновите состояние Acactor](/images/20190226-001.gif)

Во-вторых, состояние Actor поддерживается только внутри Actor и не является общим для любого объекта, кроме текущего Actor.Несвяжее значение здесь также подчеркивает, что он не может привести к изменению внутреннего состояния Actor путем изменения внешнего свойства.Это в первую очередь для того, чтобы отличаться от некоторых языков программирования, которые имеют характеристики языка "ссылки на объекты".例如：在 C#的 class 的 public 属性，假如是引用类型，那么在外部获得这个 class 之后是可以改变 class 中的属性的。Но это не допускается в режиме Actor.

![Общий доступ к состоянию Acactor](/images/20190226-003.gif)

Однако чтение данных изнутри Actor во внешний файл по-прежнему допустимо.

![Чтение состояния Acactor](/images/20190226-002.gif)

**однопоточный**.Actor обычно может принимать только один вызов в то же время.Потоки, описанные здесь, не совсем относятся к потокам на компьютере и используются для выделения терминов, используемых "Actor может обрабатывать только один запрошенный атрибут в то же время".Если actor в настоящее время принимает вызов, оставшиеся вызовы блокируются до тех пор, пока вызов не будет завершен, прежде чем следующий запрос будет разрешен.На самом деле это похоже на механизм блокировки синхронизации.Этот механизм позволяет избежать возможности проблемы слаженности при изменении внутреннего состояния Actor.具体一点说明：如果使用 100 个线程对一个 Actor 进行并发调用，让 Actor 对状态中的一个 int 变量进行 ++ 操作。В конечном счете значение этого состояния должно быть 100.

![Вызов Actor в то же время](/images/20190226-004.gif)

Однако однопоточность также не является абсолютной, и однофайловая обработка разрешена без запроса на проблему однофайлового выполнения.Например, чтение состояния в Actor, который обычно не имеет проблемы с вхождами, позволяет операции симулы на этом этапе.

![Чтение Actor в то же время](/images/20190226-005.gif)
