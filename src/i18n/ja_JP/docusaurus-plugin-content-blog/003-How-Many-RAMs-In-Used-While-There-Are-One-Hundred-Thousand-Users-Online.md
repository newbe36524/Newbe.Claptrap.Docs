---
date: 2020-06-18
title: 10万人の同時オンラインユーザーは、どのくらいのメモリを必要としますか? -- Newbe.Claptrap フレームワークの水平拡張実験
---

Newbe.Claptrap プロジェクトは、`リアクティブ`、`アクタ モード`、および`イベント トレーサビリティ`を理論的に構築するサービス側開発フレームワークのセットです。この記事では、フレームワークの水平方向の拡張能力について説明します。

<!-- more -->

## 前の情報

長い間、私たちは今日再び会います。まず、過去のプロジェクトについて説明します：

[このフレームワークに初めてアクセスする読者は、このフレームワークに関連する基本的な理論としくみを読むためにここをクリックしてください。](001-Overview-Of-Newbe-Claptrap)

また、読者が次のリンクから情報を得るウォームアップ記事やツールも作成：

- [20 秒から 0.5 秒までのデータベース操作の最適化により、サービス側でのリアクション プログラミングの適用について説明します](008-Reactive-In-Server-1)
- [Newbe.Claptrap プロジェクト 週報 1 - まだ回転していない、最初にホイールで実行します](006-Newbe-Claptrap-Weekly-1)

## 今日のトピック

今日、Newbe.Claptrap フレームワークが水平方向に拡張され、オンライン ユーザー数の増加にどのように適合するかを検証する一連の実験プレビューを行います。

## ビジネス要件の説明

まず、今日実装するビジネス シナリオを見てみましょう：

- ユーザーが API を介してログインすると、JWT token が生成されます
- ユーザーが API を呼び出すときに、JWT token の有効性を検証します
- JWT token の発行には、通常の JWS パブリック秘密キーを使用する代わりに、各ユーザーのハッシュ検証に secret を個別に使用します
- さまざまなオンライン ユーザーが消費する必要があるメモリを確認します
- ユーザーがビルド token にログオンするには、200 ms を超える時間を費やしてはいきはありません
- tokn の検証には 10 ms を超えても時間がかかります

### 自慢は、最初にドラフトをヒット

筆者は「オンラインユーザ数」に直接関係する理論的定義を検索していないので,皆さんの理解に違いを避けるためである.著者は、まず自分の理解に基づいて、：オンラインユーザー数は、どのような技術的な要件を意味するのでしょうか?

#### オンラインでないユーザーは、オンラインになってはならない

ユーザーがログインすると、100 ms が消費されます。現在のオンライン ユーザー数が 10 人か 100 万人か。このログインは、100 ms を超える時間を消費しません。

もちろん、物理ハードウェアが限られていると、オンライン ユーザー数がしきい値 (200 万人など) を超えると、新しいユーザーがオンラインにログオンし、エラーが発生する可能性があります。

しかし、物理マシンを増やすと、このしきい値が上がり、水平拡張設計が成功すると考えることができるようにします。

#### オンライン ユーザーの場合、システム パフォーマンスのフィードバックは同じである必要があります

たとえば、オンラインのユーザーが注文の詳細を照会すると、100 ms が消費されます。したがって、現在のユーザーによる注文クエリの平均消費量は 100 ms で安定している必要があります。

もちろん、ここでは「スナップ」のような高い集中パフォーマンスの問題を排除する必要があります。ここでは、主に毎日の安定した容量の増加について説明します。(後で「スナップ」という問題について話します)

具体的には、このように理解することができます。クラウド ノート製品を作るとします。

したがって、物理マシンを増やすと、クラウド ノート製品を同時に使用するユーザーの数が増え、1 人のユーザーのパフォーマンス エクスペリエンスを犠牲にすることなく、水平スケール設計が成功すると考えています。

今回の実験では,ユーザがすでにログインしている場合,JWTの有効性を検証した場合の成長は約0.5 msであった.

## 時系列リレーションシップを呼び出します

![Timing diagram](/images/20200621-001.png)

簡単な説明：

1. クライアントがログイン要求を開始すると、階層ごとに UserGrain に伝達されます
2. UserGrain は Claptrap を内部的にアクティブ化して、UserGrain の状態データを維持します。ユーザー名、パスワード、および JWT 署名用の Secret が含まれます。
3. 後続のビルド JWT ビルドと検証では、UserGrain のデータが直接使用されます。UserGrain のデータは一定期間メモリに "キャッシュ" されるためです。したがって、その後の JWT の生成と検証は非常に高速になります。実測値は約 0.5 ms です。

## 物理的な構造設計

![物理的な構造設計](/images/20200618-001.png)

上の図に示すように、これはテストされた物理コンポーネントの：

| 名前                  | 説明                                                                        |
| ------------------- | ------------------------------------------------------------------------- |
| WebAPI              | WebAPI インターフェイスを外部に公開します。token にログインして認証するためのインターフェイスを提供します。              |
| Orleans Cluster     | Grain のコア プロセスをホストします。                                                    |
| Orleans Gateway     | Orleans Cluster は基本的に同じですが、WebAPI は Gateway とのみ通信できます                     |
| Orleans Dashboard   | Orleans Gateway は基本的に同じですが、Dashboard のインプレッションを追加して、Orleans クラスター全体を表示します |
| Consul              | Orleans クラスターのクラスターの検出と保守に使用されます                                          |
| Claptrap DB         | Newbe.Claptrap フレームワークのイベント データと状態データを保持するために使用します                        |
| Influx DB & Grafana | Newbe.Claptrap 関連のパフォーマンス メトリック データを監視するために使用します                          |

今回の実験の Orleans クラスタノードの数は、実際には Cluster + Gateway + Dashboard の合計数です。以上の分割は,実際には機能設定の違いによる区別である.

水平拡張機能をテストする物理ノードは、主に Orleans Cluster と Orleans Gateway の 2 つの部分です。メモリ使用量は、次の条件で個別にテストされます。

| Orleans Dashboard | Orleans Gateway | Orleans Cluster |
| ----------------- | --------------- | --------------- |
| 1                 | 0               | 0               |
| 1                 | 1               | 1               |
| 1                 | 3               | 5               |

この実験では、Windows Docker Desktop と WSL 2 を組み合わせた展開テストを使用しました。

上記の物理構造は、実際には、この実験で最も複雑な状況に合って設計されています。実際には、ビジネス シナリオが十分に単純であれば、物理構造をトリミングできます。詳細については、以下の「FAQ」の説明を参照してください。

## 実際のテスト データ

以下では,異なるクラスタ規模とユーザ数をそれぞれテストする

### 0 Gateway 0 Cluster

デフォルトでは、Dashboard ノードを起動すると、次の図に示すように、portainer を使用して container が占有するメモリが約 200 MB：

![初期メモリフットプリント](/images/20200621-002.png)

テスト コンソールを使用して、WebAPI に 30,000 件の要求を行います。バッチごとに 100 件の要求がバッチで送信されます。

約 2 分間の待機の後、次の図に示すように、約 9.2 GB のメモリをもう一度確認します：

![30,000人のユーザー](/images/20200621-003.png)

したがって、各オンライン ユーザーが消費する必要があるメモリの状況は、約 (9.2\*1024-200)/30000 = 0.3 MB であると単純に見積もっています。

さらに、いくつかのセカンダリ データを表示できます：

CPU 使用率

![CPU 使用率](/images/20200621-004.png)

ネットワーク スループット

![ネットワーク スループット](/images/20200621-005.png)

Orleans ダッシュボードの状況。左上の TOTAL ACTIVATIONS の 30,000 は、現在のメモリに存在する UserGrain の数を示し、さらに 3 つは Dashboard で使用される Grain です。

![Orleans ダッシュボードの状況](/images/20200621-006.png)

Grafana で Newbe.Claptrap を表示するイベントの平均処理時間は、約 100 ~ 600 ms です。このテストは、主にメモリの状態であり、処理時間は30秒に1回であるため、サンプル数はそれほど多くはありません。処理時間については、今後の記事で詳しく説明します。

![時間の平均処理時間](/images/20200621-007.png)

Grafana で Newbe.Claptrap を表示するイベントの保存にかかる平均時間は、約 50 ~ 200 ms です。イベントの保存時間は、イベント処理の主要な部分です。

![30,000人のユーザー](/images/20200621-009.png)

Grafana で Newbe.Claptrap を表示したイベントが処理された合計数です。1 つのログインが 30,000 回行われます。

![イベント処理の合計数です](/images/20200621-008.png)

### 1 Gateway 1 Cluster

次に、テスト用にさらに 2 つのノードを追加してテストします。

Orleans クラスタ ノードの数は、実際には Cluster + Gateway + Dashboard の合計数です。したがって、前のテストと比較すると、ノードの数は 3 です。

テストしたメモリ使用量は次の通りです：

| ユーザーの数 | ノードの平均メモリ | メモリの合計使用量          |
| ------ | --------- | ------------------ |
| 10000  | 1.8 GB    | 1.8\*3 = 5.4 GB  |
| 20000  | 3.3 GB    | 3.3\*3 = 9.9 GB  |
| 30000  | 4.9 GB    | 4.9\*3 = 14.7 GB |

たとえば、30,000 人のユーザーの場合、ユーザーあたりの平均メモリ使用量は約 (14.7\*1024-200\*3)/30000 = 0.48 MB です

ノード数が増加し、平均消費メモリが増加しているのはなぜですか。筆者は,検証が行わなされていない：ノードが増加し,実際にはノード間の通信に余分なメモリが必要となるため,平均的に増加すると推測する.

### 3 Gateway 5 Cluster

再びノードを増やします。合計ポイント数は 1 (dashboard) + 3 (cluster) + 5 (gateway) = 9 ノードです

テストしたメモリ使用量は次の通りです：

| ユーザーの数 | ノードの平均メモリ | メモリの合計使用量          |
| ------ | --------- | ------------------ |
| 20000  | 1.6 GB    | 1.6\*9 = 14.4 GB |
| 30000  | 2 GB      | 2\*9 = 18 GB     |

たとえば、30,000 人のユーザーの場合、ユーザーあたりの平均メモリ使用量は約 (18\*1024-200\*9)/30000 = 0.55 MB です

### 10 万人のユーザーがどれだけのメモリを必要とするか。

上記のすべてのテストは、特別な数字である30,000人のユーザー数でテストされています。ユーザー数を増やし続けると、メモリはテスト マシンのメモリ許容量を超えます。(2つの16Gのスポンサーを求める)

ユーザー数を増やし続けると、オペレーティング システムの仮想メモリの使用が開始されます。実行は可能ですが、運用効率が低下します。元のログインには 100 ms しかかかっていきはありません。仮想メモリを使用するユーザーは、2 秒が必要です。

したがって、速度が低下した場合、検証に必要なメモリの量にはほとんど意味がありません。

ただし,これは登録を継続できないという意味ではなく,以下では1+1+1の場合,10万人のユーザが全員ログインした場合である.(10万人のユーザーが同時にオンラインであり、いくつかのメモリバーを追加し、悪いお金ではありません。)

![10万人のユーザー](/images/20200621-010.png)

## ソースビルドの説明

このテストのコードは、テキストの最後にサンプル コード ベースにあります。読者が自分で実験できるように、主に docker-compose を使用してビルドと展開を行います。

したがって、テスト マシンの唯一の環境要件は、Docker Desktop を正しくインストールすることです。

最新のサンプル コードは、次のいずれかのアドレスから取得できます：

- <https://github.com/newbe36524/Newbe.Claptrap.Examples>
- <https://gitee.com/yks/Newbe.Claptrap.Examples>

### クイックスタート

コンソールを使用して `src/Newbe.Claptrap.Auth/LocalCluster` します。次のコマンドを実行すると、すべてのコンポーネントをローカルで起動できます：

```
docker-compose up -d
```

途中で Dockerhub でホストされているパブリック イメージをプルする必要がある場合は、関連するアクセラレータがローカルで正しく構成されていることを確認して、すばやく構築できるようにしてください。[、このドキュメントを参照して設定できます](https://www.runoob.com/docker/docker-mirror-acceleration.html)

正常に起動すると、`docker ps` を使用してすべてのコンポーネントを表示できます。

```bash
PS>docker ps
CONTAINER ID        IMAGE                                                                            COMMAND                  CREATED             STATUS              PORTS                                                                                                                              NAMES
66470e5393e2        registry.cn-hangzhou.aliyuncs.com/newbe36524/newbe-claptrap-auth-webapi          "dotnet Newbe.Claptr…"   4 hours ago         Up About an hour    0.0.0.0:10080->80/tcp                                                                                                              localcluster_webapi_1
3bbaf5538ab9        registry.cn-hangzhou.aliyuncs.com/newbe36524/newbe-claptrap-auth-backendserver   "dotnet Newbe.Claptr…"   4 hours ago         Up About an hour    80/tcp, 443/tcp, 0.0.0.0:19000->9000/tcp, 0.0.0.0:32785->11111/tcp, 0.0.0.0:32784->30000/tcp                                       localcluster_dashboard_1
3f60f51e4641        registry.cn-hangzhou.aliyuncs.com/newbe36524/newbe-claptrap-auth-backendserver   "dotnet Newbe.Claptr…"   4 hours ago         Up About an hour    80/tcp, 443/tcp, 9000/tcp, 0.0.0.0:32787->11111/tcp, 0.0.0.0:32786->30000/tcp                                                      localcluster_cluster_gateway_1
7d516ada2b26        registry.cn-hangzhou.aliyuncs.com/newbe36524/newbe-claptrap-auth-backendserver   "dotnet Newbe.Claptr…"   4 hours ago         Up About an hour    80/tcp, 443/tcp, 9000/tcp, 30000/tcp, 0.0.0.0:32788->11111/tcp                                                                     localcluster_cluster_core_1
fc89fcd973f9        grafana/grafana                                                                  "/run.sh"                4 hours ago         Up 6 seconds        0.0.0.0:23000->3000/tcp                                                                                                            localcluster_grafana_1
1f10ed0eb25f        postgres                                                                         "docker-entrypoint.s…"   4 hours ago         Up About an hour    0.0.0.0:32772->5432/tcp                                                                                                            localcluster_claptrap_db_1
d5d2bec74311        adminer                                                                          "entrypoint.sh docke…"   4 hours ago         Up About an hour    0.0.0.0:58080->8080/tcp                                                                                                            localcluster_adminer_1
4c4be69f2f41        bitnami/consul                                                                   "/opt/bitnami/script…"   4 hours ago         Up About an hour    8300-8301/tcp, 8500/tcp, 8301/udp, 8600/tcp, 8600/udp                                                                              localcluster_consulnode3_1
88811d3aa0d2        influxdb                                                                         "/entrypoint.sh infl…"   4 hours ago         Up 6 seconds        0.0.0.0:29086->8086/tcp                                                                                                            localcluster_influxdb_1
d31c73b62a47        bitnami/consul                                                                   "/opt/bitnami/script…"   4 hours ago         Up About an hour    8300-8301/tcp, 8500/tcp, 8301/udp, 8600/tcp, 8600/udp                                                                              localcluster_consulnode2_1
72d4273eba2c        bitnami/consul                                                                   "/opt/bitnami/script…"   4 hours ago         Up About an hour    0.0.0.0:8300-8301->8300-8301/tcp, 0.0.0.0:8500->8500/tcp, 0.0.0.0:8301->8301/udp, 0.0.0.0:8600->8600/tcp, 0.0.0.0:8600->8600/udp   localcluster_consulnode1_1
```

起動が完了したら、次のリンクから関連するインターフェイスを表示できます

| アドレスです                   | 説明                                                  |
| ------------------------ | --------------------------------------------------- |
| <http://localhost:19000> | Orleans Dashboard は、Orleans クラスター内の各ノードの状態を表示します    |
| <http://localhost:10080> | テストした API ベース アドレスを使用する Web API ベース アドレス            |
| <http://localhost:23000> | Grafana アドレスで、Newbe.Claptrap 関連のパフォーマンス メトリックを確認します |

### ソース ビルド

コンソールを使用して `src/Newbe.Claptrap.Auth` します。次のコマンドを実行すると、コードの構築をローカルで実行できます：

```bash
./LocalCluster/pullimage.cmd
docker-compose build
```

ビルドが完了すると、関連するイメージがローカルに生成されます。次に、アプリをローカルで起動：

コンソールを使用して `src/Newbe.Claptrap.Auth/LocalCluster` します。次のコマンドを実行すると、関連するコンテナーを起動できます。

```bash
docker-compose up -d
```

## よく寄せられる質問

### コードと構成の詳細が記載されていないのはなぜですか。

この記事は、主に、このシナリオの実験的実現可能性を示し、Newbe.Claptrap フレームワークを使用してコードを記述する方法を具体的に示しています。

もちろん、もう 1 つのポイントは、フレームワークが最終的にファイナリティされていないので、すべてが変更される可能性があり、コードの詳細を説明することはあまり意味がありません。

ただし、この例のビジネス ニーズ：非常に単純であるため、コードの内容も少ないため、事前に説明できます。すべては、サンプル倉庫で見つけることができます。

### Redis で Token を保存すると、上記の要件も実装できます。

今のところ、著者は、読者にどのスキームを使用するかを説得する十分な理由を持っていない、ここでも実行可能なスキームを提供し、実際にどのスキームを選択するかは、読者自身が検討する必要があり、結局、ツールが手に取るかどうか、またはそれを試してみる必要があります。

### 最大 100 人のオンライン ユーザーの場合、システムをトリミングするには、どのように行いますか。

必要なコンポーネントは、 Orleans Dashboard 、 WebAPI 、および Claptrap Db のみです。その他のコンポーネントはすべて不要です。また、コードを変更すると、Orleans Dashboard と WebAPI をマージできます。

したがって、最小サイズはプロセスとデータベースです。

### Grafana にレポートが表示されないのですか?

Grafana の最初の起動後、DataSource を手動で作成し、Dashboard をインポートする必要があります。

この実験に関連するパラメータは次のとおりです：

DataSource

- URL： http://influxdb:8086
- Database： metricsdatabase
- User： claptrap
- Password： claptrap

[Dashboard 定義ファイルについては、ここをクリックしてください](https://github.com/newbe36524/Newbe.Claptrap/blob/develop/src/Docker/Monitor/grafana/claptrap.json)

### テストマシンの物理的な構成は何ですか?

専用のメモリは使用され、テストを開始する前に 16 GB のメモリが消費されています。以下は、テストマシンの体格データ(海洋ゴミ、約3,500元)の：

プロセッサ インテル Xeon (Xeon) E5-2678 v3 – 2.50 GHz 12 コア 24 スレッド マザーボード HUANANZHI X99-AD3 GAMING (ウェルズバーグ) グラフィックス Nvidia GeForce GTX 750 Ti (2 GB / Nvidia) メモリ 32 GB (サムスン DDR3L 1600MHz) 2013 年の高齢メモリ メイン ドライブ キングストン SA400S37240G (240 GB /SSD)

より良い物理構成があれば、より優れたデータが得られると思います。

### 0.3 MB の平均ユーザーあたりの占有率も高すぎると感じています

フレームワークはまだ最適化されています。未来は良くなるだろう。

<!-- md Footer-Newbe-Claptrap.md -->
