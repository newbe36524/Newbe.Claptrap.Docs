---
title: '設計。'
metaTitle: '火車售票系統-設計。'
metaDescription: '火車售票系統-設計。'
---

> [當前查看的版本是由機器翻譯自簡體中文,並進行人工校對的結果。若文檔中存在任何翻譯不當的地方,歡迎點擊此處提交您的翻譯建議。](https://crwd.in/newbeclaptrap)

## 業務分析。

### 業務邊界。

該系統僅包含車票的餘票管理部分。即查詢剩餘座位,下單買票減座。

而生成訂單資訊,付款,流量控制,請求風控等等都不包含在本次討論的範圍中。

### 業務用例。

- 查詢余票,能夠查詢兩個車站間可用的車次以及剩餘座位數量。
- 查詢車次對應的車票餘票,能夠查詢給定的車次,在各個車站之間還有多少剩餘座位。
- 支援選座下單,客戶能夠選擇給定的車次及座位,並下單買票。

## 實現難點分析。

### 餘票管理。

火車票餘票管理的難點,其實就在於其餘票庫存的特殊性。

普通的電商商品,以 SKU 為最小單位,每個 SKU 之間相互獨立,互不影響。

火車票餘票,卻有所不同,因為余票會受到已賣票起終點而受到影響。下面結合一個簡單的邏輯模型,來詳細的瞭解一下這種特殊性。

現在,我們假設存在一個車次,分別經過 a,b,c,d 四個網站,同時,我們簡化場景,假設車次中只有一個座位。

那麼在沒有任何人購票之前,這個車次的餘票情況就如下所示：

| 起終點。 | 餘票量。 |
| ---- | ---- |
| a,b。 | 1。   |
| a,c。 | 1。   |
| a,d。 | 1。   |
| b,c。 | 1。   |
| b,d。 | 1。   |
| c,d。 | 1。   |

如果現在有一位客戶購買了一張 a,c 的車票。那么由于只有一个座位，所以除了 c,d 之外的余票也就都没有。餘票情況就變成了如下所示：

| 起終點。 | 餘票量。 |
| ---- | ---- |
| a,b。 | 0。   |
| a,c。 | 0。   |
| a,d。 | 0。   |
| b,c。 | 0。   |
| b,d。 | 0。   |
| c,d。 | 1。   |

更直白一點,如果有一位客戶購買了全程車票 a,d,那麼所有的餘票都將全部變為 0。因為這個座位上始終都坐著這位乘客。

這也就是火車票的特殊性：同一個車次的同一個座位,其各個起終點的餘票數量,會受到已售出的車票的起終點的影響。

延伸一點,很容易得出,同一車次的不同座位之間是沒有這種影響的。

### 餘票查詢。

正如上一節所述,由於余票庫存的特殊性。對於同一個車次 a,b,c,d,其可能的購票選擇就有 6 種。

並且我們很容易就得出,選擇的種類數的計算方法實際上就是在 n 個網站中選取 2 個的組合數,即 c(n,2) 。

那麼如果有一輛經過 34 個網站的車次,其可能的組合就是 c(34,2) = 561 。

如何高效應對可能存在的多種查詢也是該系統需要解決的問題。

## Claptrap 主體設計。

![Train Ticketing System Design。](/images/20200720-001.png)

### 將同一車次上的每個座位都設計為一個 Claptrap - SeatGrain。

該 Claptrap 的 State 包含有一個基本資訊。

| 類型。                                    | 名稱。         | 說明                                                                    |
| -------------------------------------- | ----------- | --------------------------------------------------------------------- |
| IList&lt;int&gt;           | Stations。   | 途徑車站的 id 清單,開頭為始發站,結尾為終點站。主要購票時進行驗證。                                  |
| Dictionary&lt;int, int&gt; | StationDic。 | 途徑車站 id 的索引反向字典。Stations 是 index-id 的清單,而該字典是對應的 id-index 的字典,為了加快查詢。 |
| List&lt;string&gt;         | RequestIds。 | 關鍵屬性。每個區間上,已購票的購票 id。例如,index 為 0 ,即表示車站 0 到車站 1 的購票 id。如果為空則表示暫無認購票。 |

有了這數據結構的設計,那麼就可以來實現兩個業務了。

#### 驗證是否可以購買。

透過傳入兩個車站 id,可以查詢到這個作為是否屬於這個 SeatGrain 。並且查詢到起終點對應的所有區間段。只要判斷這個從 RequestIds 中判斷是否所有的區間段都沒有購票 Id 即可。若都沒有,則說明可以購買。如果有任何一段上已有購票 Id,則說明已經無法購買了。

舉例來說,當前 Stations 的情況是 10,11,12,13. 而 RequestIds 是 0,1,0。

那麼,如果要購買 10->12 的車票,則不行,因為 RequestIds 第二個區間已經被購買。

但是,如果要購買 10->11 的車票,則可以,因為 RequestIds 第一個區間還無人購買。

#### 購買。

將起終點對應在 RequestIds 中所有的區間段設置上購票 Id 即可。

### 將同一車次上的所有座位的餘票情況設計為一個 Claptrap - TrainGran。

該 Claptrap 的 State 包含有一些基本資訊。

| 類型。                                              | 名稱。        | 說明                                                                                    |
| ------------------------------------------------ | ---------- | ------------------------------------------------------------------------------------- |
| IReadOnlyList&lt;int&gt;             | Stations。  | 途徑車站的 id 清單,開頭為始發站,結尾為終點站。主查詢時進行驗證。                                                   |
| IDictionary&lt;StationTuple, int&gt; | SeatCount。 | 關鍵屬性。StationTuple 表示一個起終點。集合包含了所有可能的起終點的餘票情況。例如,根據上文,如果該車次經過 34 個地點,則該字典包含有 561 個鍵值對。 |

基於以上的數據結構,只需要在每次 SeatGrain 完成下單後,將對應的資訊同步到該 Grain 即可。

例如,假如 a,c 發生了一次購票,則將 a,c / a,b / b,c 的餘票都減一即可。

這裡可以藉助本框架內置的 Minion 機制來實現。

值得一提的是,這是一個比"最小競爭資源"大的設計。因為查詢場景在該業務場景中不需要絕對的快速。這樣設計可以減少系統的複雜度。

## Id。

![Train Ticketing System Id。](/images/20200813-001.png)
