---
title: 'アトールモード'
metaTitle: 'アトールモード'
metaDescription: 'アトールモード'
---

> [現在表示されているバージョンは、機械が簡体字中国語から翻訳され、手動校正の結果です。ドキュメントに不適切な翻訳がある場合は、こちらをクリックして翻訳提案を提出してください。](https://crwd.in/newbeclaptrap)

アクター モードは、同時実行プログラミング モデルです。このプログラミング モデルの適用により、いくつかのシステムの同時実行の問題を解決できます。ここで説明する同時実行の問題は、コンピュータが同じデータを論理的に処理するときに、複数の同時要求が存在すると、データに誤った問題が生じる可能性があることを意味します。この問題は、マルチスレッド プログラミングで発生する問題です。単純な例として、同期ロックなしで 100 個のスレッドを使用してメモリ内の 1 つを同時に実行する場合`int`変数の実行`++`操作。その後、最終的にこの変数の結果は 100 未満になる傾向があります。ここで、Actor モードはこの問題を回避します。

まず、わかりやすくするために、読者はここでアクターをオブジェクトとして考えることができます。オブジェクト指向言語 (Java、C# など) では、アクターは`新しい`キーワードによって作成されたオブジェクト。しかし、このオブジェクトには特別な特徴があります。：

**自分に属する状態を持つ**。オブジェクトは、オブジェクト指向言語の基本的な機能である独自のプロパティを持つことができます。Actor モードでは、これらのプロパティはすべてまとめて`アクトーの状態 (ステート)`。アクターの状態は、アクター自体によって維持されます。

これは2つの点を強調しています。：

第1に、アクターの状態は、それ自体によってのみ変更することができ、アクターの状態を外部から変更するには、アクターを呼び出すことによってのみ変更できます。

![アクトーの状態の更新](/images/20190226-001.gif)

第 2 に、アクターの状態はアクター内でのみ維持され、現在の Tor 以外のオブジェクトと共有されません。ここで言う非共有は、外部属性の変更によってアクターの内部状態の変化を引き起こすことができないことも強調します。これは主に、"オブジェクト参照" 言語特性を持つ一部のプログラミング言語と区別するために行われます。例えば：C# の`クラシック`その`パブリック`プロパティは、参照型の場合は、外部で取得されます。`クラシック`その後、変更することができます`クラシック`のプロパティ。ただし、これはアクター モードでは許可されません。

![共有アトールステータス](/images/20190226-003.gif)

ただし、Actor 内から外部へのデータの読み取りは許可されています。

![アトール状態の読み取り](/images/20190226-002.gif)

**シングルスレッド**。通常、アクターは一緒に 1 つの呼び出ししか受け付けることができません。ここで説明するスレッドは、コンピュータ内のスレッドを正確に参照せず、"Tor が同時に 1 つの要求しか処理できない特性" を強調するために使用される単語です。現在の Actor が呼び出しを受け取っている場合、残りの呼び出しはブロックされ、呼び出しが終了するまで次の要求は許可されます。これは、実際にはロックを同期するメカニズムに似ています。このメカニズムにより、アクターの内部状態を変更するときに同時実行の問題が発生する可能性が回避されます。具体的な説明：100 個のスレッドを使用して 1 つのアクターに同時呼び出しを行った場合、アクターは状態の 1 つに対して実行できます。`int`変数が進行`++`操作。最終的な状態の数値は 100 である必要があります。

![同時呼び出しアトール](/images/20190226-004.gif)

ただし、シングル スレッドは絶対ではなく、同時実行の問題のない要求では同時処理が許可されます。たとえば、通常、同時実行の問題を持つ Actor の状態を読み取ると、この時点で同時実行操作が許可されます。

![同時読み取りアトール](/images/20190226-005.gif)
