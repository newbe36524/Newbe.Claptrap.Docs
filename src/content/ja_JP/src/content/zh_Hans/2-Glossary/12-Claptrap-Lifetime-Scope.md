---
title: 'Claptrapライフサイクル(Claptrap Lifetime Scope)'
metaTitle: 'Claptrapライフサイクル(Claptrap Lifetime Scope)'
metaDescription: 'Claptrapライフサイクル(Claptrap Lifetime Scope)'
---

> [現在表示されているバージョンは、機械が簡体字中国語から翻訳され、手動校正の結果です。ドキュメントに不適切な翻訳がある場合は、こちらをクリックして翻訳提案を提出してください。](https://crwd.in/newbeclaptrap)

Claptrap のライフサイクルは、著者の見解に基づいて 2 つのカテゴリに分類されます。：ランタイム ライフサイクルとデザイン時のライフ サイクル。

## ランタイムのライフ サイクル。

ランタイム ライフサイクルとは、Claptrap システムの実行中にメモリ内の個々のオブジェクトのライフサイクル動作です。たとえば、次のようにします。：Web システムでは、通常、各 Web 要求がライフサイクルとして割り当てられ、Claptrap システムにも同様のライフサイクル設計があります。これらのライフサイクルは、開発者のコンポーネントの拡張やビジネス開発に影響を与えます。Claptrap フレームワークのランタイム ライフサイクルは、次の部分に分かれています。：プロセス レベル (Process)、Claptrap レベル、およびイベント プロセッサ レベル (Event Handler)。

プロセス レベル。プロセス レベルでライフサイクルとして設計されたオブジェクトは、通常の意味でのシングルトン オブジェクトに属します。実行中の各 Claptrap プロセスには、独自のシングルトン オブジェクトがあります。一般的には、Claptrap フレームワークでは、永続レイヤーへのイベントの書き込み速度を向上させるために、各永続レイヤー ターゲットが 1 つのバッチ プロセッサ (Batch Event Saver) に対応します。プロセスのライフ サイクル全体を通じて 1 つのインスタンスしか存在せず、対応する永続レイヤーに対応し、イベントを永続的なレイヤーにマージして書き込み、書き込みパフォーマンスを向上させます。一般に、プロセス レベルのライフ サイクルとして設計されたオブジェクトには、次の 1 つ以上の特性があります。：

1. プロセスのライフ サイクル全体を通じて実行する必要があるロジックまたはコード。通常、Lazy とシングルトンの方法で実装できます。
2. プロセスのライフ サイクル全体を通じて必要なオブジェクトは 1 つだけです。例えば、Claptrap Design StoreやClaptrap Optionsなど。
3. プロセスのライフ サイクル全体を通じて、1 つのオブジェクトのみを含めることができます。たとえば、Orleans Client.

Claptrap グレード。Claptrap レベルのライフサイクルのオブジェクトは、Claptrap がアクティブ化されると作成され、Claptrap の不活性化とともに解放されます。これらのオブジェクトは、通常、Claptrap Identity と強い相関関係を持っています。例えば、そのClaptrap Identityに関連付けられたClaptrap Design、Event Saver、Event Loader、State Saver、State Loaderなどだ。

イベント プロセッサ レベル (Event Handler)。イベント プロセッサ レベルのライフサイクル オブジェクトは、イベント プロセッサが作成され、イベント プロセッサが解放された後に解放されます。Web 対応では、このレベルのライフサイクルは Web 要求のライフ サイクルに似ています。通常、統合データベース トランザクションの作業単位は、このレベルに分類されます。

## デザイン時のライフ サイクル。

設計時のライフサイクルとは、Claptrap に対応するビジネスオブジェクトのライフサイクルを指します。これは、プログラムが実行されているかどうか、あるいはプログラムを使用するかどうかとは無関係です。具体的な例として、通常の E コマース システムでの注文を示します。1 つの注文のアクティブなビジネス 時間の制限は、通常、3 ~ 6 か月を超えません。この時間の制限を超えると、注文のデータは変更できません。この「3~6ヶ月」の時間制限は、注文の設計時間ライフサイクルと呼ばれます。Claptrap システムでは、オブジェクトが設計時のライフ サイクルを超えた場合、"Claptrap をアクティブ化する必要はありません" として表示されます。したがって、次の推論を得ることができます。：

1. Claptrap が既に保存されているイベントは意味を失い、これらのイベントを削除すると空き領域が確保されます。
2. Claptrap 対応するビジネス・コードは、保守する必要がなくなり、参照を削除するか、コードを削除するかを選択できます。

したがって、Claptrap の設計ライフサイクルが短いほど、リソースの占有とコード保守コストの削減が容易になり、逆にストレージ コストと保守が困難になります。したがって、Claptrap システムを設計するときは、設計時のライフサイクルを短くする傾向があります。そして、この用語は、実際には完全に「デザイン」によって決定される直接反応します。 次に、一般的に使用される設計時ライフサイクルセグメンテーションをいくつか示します。

### ビジネス境界の分割。

これは、最も一般的な分割です。ドメイン モデリングの要件に基づいてビジネス オブジェクトを分割します。また、これらのビジネス オブジェクトには、通常、固定ライフサイクルがあります。前述の「注文」は、ビジネス境界によるライフサイクルの分割の一般的な例です。このメソッドを使用して分割する場合、Claptrap が「最小競合リソース範囲よりも大きい」という基本的な要件を満たすことに注意してください。開発者は、この分割を「列車チケットシステム」の例で体験することができます。

### 条件境界分割。

一般に、ビジネス境界分割に基づいて、合理的なライフサイクルを分割することができました。ただし、ビジネス境界だけで分割すると、設計時のライフ サイクルが永続的なオブジェクトが表示されることがあります。これらのオブジェクトに非常に集中的なイベント操作がある場合。したがって、発生するイベントの量が大幅に増加します。そのために、設計時のライフサイクルを短縮するヒューマンコントロールを導入しました。この分割は、特定の条件に基づいて分割されます。したがって、条件付き境界分割と呼ばれます。そして、最も古典的なのは、時間制限を使用して分割することです。

ここでは、クイック スタートの例のショッピング カート オブジェクトを使用して、この分割を説明します。まず、ショッピングカートは、ユーザーに関連するオブジェクトであり、ユーザーがこのシステムに常に存在している限り、アクティブ化される可能性があり、つまり、その設計ライフサイクルは「永続的」である。したがって、関連するイベントを削除することはできませんし、ショッピング カート データの正確性を確保するために永続的に保存する必要があります。しかし、1年前にショッピングカートが発生したイベントについて、もはや気にしていない場合。個々のユーザーのショッピング カートを年ごとに手動で分割できます。同時に、隣接する2年間のショッピングカートでステータスコピーを行うことができます。これにより、前年のステータス データが継続され、ユーザーのショッピング カートが設計時のライフ サイクルを短くし、ビジネスに影響を与えることはありません。中国の古典的な伝説「愚か者」を利用して、この時間ベースの設計時間ライフサイクルセグメンテーションを理解することができます。物語では、愚か者は人間であり、長生きすることはできません(短いデザインライフサイクル)が、愚か者の精神(長いデザイン時間のライフサイクル)は、将来の世代とともに継続することができ、したがって、山を移動する偉業を完了することができます。「愚か者」の各世代が世代交代を行うと、上記の「ステータスコピー」(精神的な継続)が発生します。これにより、設計時のライフサイクルを短くすることで、設計時のライフサイクルの長いまたは永続的な要件が実現します。
