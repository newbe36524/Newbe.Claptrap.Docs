---
title: 'Первый шаг - создать проект и реализовать простую корзину'
metaTitle: 'Первый шаг - создать проект и реализовать простую корзину. . . Ньюб.Клэптрап'
metaDescription: 'Первый шаг - создать проект и реализовать простую корзину'
---

Давайте внедрим простое требование «корзины электронной коммерции», чтобы увидеть, как развиваться с помощью Newbe.Claptrap.

<!-- more -->

## Потребности бизнеса

Реализуйте простое требование «электронной коммерции корзину» где несколько простых бизнес：

- Получите товары и количества в текущей корзине
- Добавить товары в корзину
- Удалите определенные элементы из корзины

## Установка шаблонов проектов

Во-первых, вы должны убедиться, что вы установили . NetCore SDK 3.1.[Вы можете нажать здесь для последней версии для установки](https://dotnet.microsoft.com/download)。

После установки SDK откройте консоль и запустите следующие команды для установки последних шаблонов проектов：

```bash
dotnet новый - новый installbe.Claptrap.Template
```

После установки можно увидеть шаблоны проекта, которые уже были установлены в результатах установки.

![Установлен шаблон Newbe.claptrap](/images/20200709-001.png)

## Создание проекта

Выберите местоположение для создания папки, и в этом примере выбирается`D:\REpo`Создание имени под названием`HelloClaptrap`папку .Папка будет использоваться в качестве папки кода для новых проектов.

Откройте консоль и переключите рабочий каталог на`D:\Rэпо-HelloClaptrap`。Затем запустите следующую команду для создания проекта：

```bash
dotnet newbe.claptrap - название HelloClaptrap
```

> В целом мы рекомендуем`D:\Rэпо-HelloClaptrap`Создайте папку в виде склада Git.Управляйте исходным кодом с помощью управления версиями.

## Компиляция и запуск

Как только проект будет создан, вы можете составить решение с вашим любимым IDE открытым.

После компиляции запустите проекты в Интернете и BackendServer с функцией Startup на IDE.(VS необходимо запустить сервисную консоль, и если вы используете IIS Express, вам нужно, чтобы разработчик посмотрел соответствующий номер порта для доступа к веб-странице)

Как только начало завершено, вы можете`http://localhost:36525/swagger`Адрес для просмотра API описание образца элемента.Это включает в себя три основных API：

- `Получить` `/api/Cart/{id}` Получите товары и количества в конкретной корзине для покупок ID
- `Поместить` `/api/Cart/{id}` Добавить новый товар к покупке указанного идентификатора
- `Удалить` `/api/Cart/{id}` Удалите определенный товар из корзины указанного идентификатора

Вы можете попробовать сделать несколько звонков в API через кнопку Try It Out на интерфейсе.

> - [Как начать несколько проектов одновременно в VS](https://docs.microsoft.com/zh-cn/visualstudio/ide/how-to-set-multiple-startup-projects?view=vs-2019)
> - [Как начать несколько проектов в Райдер в то же время](https://docs.microsoft.com/zh-cn/visualstudio/ide/how-to-set-multiple-startup-projects?view=vs-2019)
> - [Используйте Облако Huawei для ускорения nuget восстановить скорость](https://mirrors.huaweicloud.com/)

## Сначала добавить продукт, никакого эффекта?

Да, Вы правы.В шаблоне проекта есть BUGS в реализации бизнеса.

Далее давайте откроем проект и устранение неполадок и разявим эти ошибки, добавив некоторые точки разрыва.

И, найдя BUG, вы можете понять процесс потока кода фреймворка.

## Добавление точек разрыва

Следующие необходимо увеличить расположение точек разрыва на основе различных инструкций IDE, и вы можете выбрать IDE вы привыкли работать.

Если у вас в настоящее время нет IDE под рукой, вы также можете пропустить этот раздел и прочитать непосредственно, что следует.

### Визуальная студия

Начните оба проекта в одно и то же время, как упоминалось выше.

Пункты безубыточности импорта：Откройте окно Breakpoint, нажмите кнопку, выберите из-под элемента`брейк-пойнты.xml`Файл.Соответствующее операционное местоположение можно найти на двух скриншотах ниже.

![Окно моментов открытых точек](/images/20200709-002.png)

![Пункты безубыточности импорта](/images/20200709-003.png)

### Всадника

Начните оба проекта в одно и то же время, как упоминалось выше.

Райдер в настоящее время не имеет функцию импорта брейк-пойнта.Поэтому необходимо вручную создавать точки разрыва в следующих местах：

| Файл                             | Номер строки |
| -------------------------------- | ------------ |
| КартКонтроллер                   | 30           |
| КартКонтроллер                   | 34           |
| КартГрейн                        | 24           |
| КартГрейн                        | 32           |
| Обработчик событий AddItemToCart | 14           |
| Обработчик событий AddItemToCart | 28           |

> [Go To File позволяет быстро определить, где находятся ваши файлы](https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_File.html?keymap=visual_studio)

## Начало отладки

Далее мы берем запрос, чтобы увидеть, как весь код работает.

Во-первых, давайте отправим запрос POST через интерфейс чванства и попытаемся добавить элементы в корзину.

### Старт картКонтроллера

Первым спасательным кругом является код контроллера для слоя Web API：

```cs
(HttpPost){id}")]
публичная задача async<IActionResult> AddItemAsync (int id, [FromBody] Ввод ввода AddItem)
{
    вар картгрейн s _grainFactory.GetGrain<ICartGrain>(id. ToString ();
    Вар пунктов s ждут cartgrain.AddItemAsync (вход. SkuId, вход. Граф);
    возвращение Json (предметы);
}
```

В этом коде мы передаем`_grainFactory`для создания`ИКартГрейн`Экземпляр.

Этот экземпляр по существу является прокси, который указывает на определенное зерно в Backend Server.

Входящий идентификатор можно считать уникальным идентификатором для экземпляра местоположения.В этом бизнес-контексте его можно понимать как "корзина ID" или "идентификатор пользователя" (если у каждого пользователя есть только одна корзина).

Продолжить с отладкой и перейти к следующему шагу, давайте посмотрим, как внутри ICartGrain работ.

### КартГрейн Старт

Следующей точкой остановки является код CartGrain.：

```cs
публичная задача async<Dictionary<string, int>> AddItemAsync (строка skuId, int кол)
{
    var evt s.this. Создать вент (новый AddItem ToCartevent)
    {
        Граф - Граф,
        SkuId skuId,
    });
    ждут Claptrap.HandleEventAsync (evt);
    Возвращение StateData.Items;
}
```

На этом этапе код был запущен к конкретному объекту корзины.

Вы можете видеть через отлада, что как входящие skuId, так и подсчет являются параметрами, передаваемыми от контроллера.

Здесь вы можете сделать эти вещи：

- Изменить данные в Claptrap с событиями
- Читать данные, сохраненные в Claptrap

В этом коде мы создаем`Событие AddItemToCart`Объект для представления изменения корзины.

Затем он передается в Claptrap для обработки.

Claptrap обновляет данные о состоянии после принятия события.

Наконец, мы возвращаем вызывающему абоненту StateData.Items.(На самом деле, StateData.Items является быстрым свойством для Claptrap.State.Data.Items.)Так что это на самом деле все еще читать из Claptrap. )

С отладать, вы можете увидеть тип данных StateData, как показано ниже：

```cs
общественный класс CartState : IStateData
{
    публичный словарь<string, int> Предметы ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
}
```

Это состояние корзины, разработанной в образце.Мы используем`Словарь`представлять SkuId в текущей корзине и соответствующем количестве.

Продолжить отладку и перейти к следующему шагу, чтобы увидеть, как Claptrap обрабатывает входящие события.

### AddItemToCart Запуск обработчика событий

Опять же точка прерывания является следующий код：

```cs
общественный класс AddItemCartEvent Обработчик
    : НормальныйСевент Хэндлер<CartState, AddItemToCartEvent>
{
    публичное переопределение ValueTask HandleEvent (CartState StateData, AddItemToCartEvent EventData,
        IEventContext EventContext)
    {
        Элементы Var . . . stateData.Items? новый словарь<string, int>();
        если (элементы. TryGetValue (eventData.SkuId, из var itemCount))
        {
            itemCount s eventData.count;
        }
        Еще
        // {
        itemCount - eventData.Count;
        // }

        Элементы[eventData.SkuId] s itemCount;
        StateData.Items . . .
        возвращение нового ValueTask ();
    }
}
```

Этот код содержит два важных параметра, представляющих текущий статус корзины`КартаГосударство`и события, которые необходимо обрабатывать`Событие AddItemToCart`。

Мы определяем, содержит ли словарь в государстве подводную гору SkuId в соответствии с бизнес-потребностями, и обновляем его номер.

Продолжайте отладку, и код будет работать до конца этого кода.

На данный момент, через отладок, вы можете видеть, что словарь stateData.Items увеличился на один, но число 0.Причина на самом деле из-за другого фрагмента выше, что является причиной BUG, который всегда не может добавить корзину в первый раз.

Здесь не прерывайте отладку немедленно.Давайте идти вперед и пусть код пройти, чтобы увидеть, как весь процесс заканчивается.

В самом деле, продолжая отладку, точка разрыва попадает в конце cartGrain и CartController методы в свою очередь.

## На самом деле это трехуровневая архитектура!

Подавляющее большинство разработчиков понимают трехуровневую архитектуру.В самом деле, мы можем также сказать, что Newbe. Claptrap на самом деле трехуровневая архитектура.Давайте сравним это в таблице.：

| Традиционные трехъярусные        | Ньюб.Клэптрап     | Описание                                                                                                                          |
| -------------------------------- | ----------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| Презентация Презентационный слой | Слой контроллера  | Используется для стыковки внешних систем для обеспечения внешней совместимости                                                    |
| Уровень делового бизнеса         | Зерновой слой     | Бизнес-обработка на основе входящих бизнес-параметров (образец на самом деле не пишет суждения, необходимо судить о подсчете > 0) |
| Слой настойчивости               | Слой EventHandler | Обновление бизнес-результатов                                                                                                     |

Конечно, приведенная выше аналогия является простым описанием.В конкретном процессе нет необходимости слишком запутывается, это всего лишь вспомогательное понимание заявления.

## У вас также есть BUG, чтобы исправить

Затем мы возвращаемся и исправить предыдущий "Первый присоединиться Продукты не принимают эффект" вопрос.

### Это основа для рассмотрения модульного тестирования

В шаблоне проекта есть проект`HelloClap.Actors.Tests`Проект содержит модульные тесты основного бизнес-кода.

Теперь мы знаем, что`Обработчик событий AddItemToCart`Код в комментариях является основной причиной BUG.

Мы можем использовать`Тест дотнета`При запуске модульных тестов в тестовом проекте вы получаете две ошибки:

```bash
В общей сложности 1 тестовый файл соответствовал шаблону syd dh'fydd.
  X AddFirstOne [130ms]
  Сообщение об ошибке:
   D'Value будет 10, но нашел 0.
  Стек След:
     на FluentS. Execution.LateTestBoundFramework.Throw (String Message)
   на FluentS. Execution.TestFramework Provider.T. Бросьте
   на FluentS. Execution.DefaultKStrategy.HandleFailure (String Message)
   На FluentS. Execution.Ax. Scope.FailWith (Func'1 failReasonFunc)
   На FluentS. Execution.Ax. Scope.FailWith (Func'1 failReasonFunc)
   на FluentS. Execution.Ax. Scope.FailWith (Строка сообщение, объект?args)
   на FluentS.Numeric.NumericS'1.Be (T ожидается, строка, потому что, объект' becauseArgs)
   На HelloClaptrap.Actors.Tests.Cart.Events.AddItemCartEventHandler.AddFirstOne () в D:\Repo?HelloClaptrap?HelloClaptrap?HelloClaptrap?HelloClaptrap.Actors.Tests?Cart?Events?AddToCartEventHandlerTest.cs: линия 32
   На HelloClaptrap.Actors.Tests.Cart.Events.AddItemCartEventHandler.AddFirstOne () в D:\Repo?HelloClaptrap?HelloClaptrap?HelloClaptrap?HelloClaptrap.Actors.Tests?Cart?Events?AddToCartEventHandlerTest.cs: линия 32
   в NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter'1.GetResult ()
   в NUnit.Framework.Internal.AsyncToSyncAdapter.Await (Func'1 Invoke)
   в NUnit.Framework.Internal.Команды.TestMethodCommand.RunTestMethod (Контекст TestExecution)
   в NUnit.Framework.Internal.Command.TestMethod Command.Execute (контекст testExecution)
   на NUnit.Framework.Internal.Execution SimpleWorkItem.PerformWork ()

  X RemoveOne [2ms]
  Сообщение об ошибке:
   D'Value будет 90, но нашел 100.
  Стек След:
     на FluentS. Execution.LateTestBoundFramework.Throw (String Message)
   на FluentS. Execution.TestFramework Provider.T. Бросьте
   на FluentS. Execution.DefaultKStrategy.HandleFailure (String Message)
   На FluentS. Execution.Ax. Scope.FailWith (Func'1 failReasonFunc)
   На FluentS. Execution.Ax. Scope.FailWith (Func'1 failReasonFunc)
   на FluentS. Execution.Ax. Scope.FailWith (Строка сообщение, объект?args)
   на FluentS.Numeric.NumericS'1.Be (T ожидается, строка, потому что, объект' becauseArgs)
   На HelloClaptrap.Actors.Tests.Cart.Events.RemoveItemCartEventhandlerHandler.RemoveOne () в D:\Repo?HelloClaptrap?HelloClap.Actors.Tests?Cart?Events\RMoveItem от HandlerTest.cs CartEvent: линия 40
   На HelloClaptrap.Actors.Tests.Cart.Events.RemoveItemCartEventhandlerHandler.RemoveOne () в D:\Repo?HelloClaptrap?HelloClap.Actors.Tests?Cart?Events\RMoveItem от HandlerTest.cs CartEvent: линия 40
   в NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter'1.GetResult ()
   в NUnit.Framework.Internal.AsyncToSyncAdapter.Await (Func'1 Invoke)
   в NUnit.Framework.Internal.Команды.TestMethodCommand.RunTestMethod (Контекст TestExecution)
   в NUnit.Framework.Internal.Command.TestMethod Command.Execute (контекст testExecution)
   на NUnit.Framework.Internal.Execution SimpleWorkItem.PerformWork ()


Тестовый запуск не удался.
Всего тестов: 7
     Пройдено: 5
     Не удалось: 2

```

Давайте посмотрим на код для одного из неисправных модульных тестов.：

```cs
[Test]
публичная async Задача AddFirstOne ()
{
    использование var mocker - AutoMock.GetStrict ();

    ждут использования var обработчик s-mocker. Создать<AddItemToCartEventHandler>();
    var state s новый CartState ();
    var evt новый AddItemToCartEventEvent
    {
        SkuId skuId1,
        Граф s 10
    };
    ждать обработчика. HandleEvent (состояние, evt, по умолчанию);

    Государства. Элементы.Граф.Вниз.) Будьте (1);
    var (ключ, значение) s состояние. Элементы.Одинократный ();
    Ключ. "Что") Будьте (evt. Скуид);
    Значение. "Что") Будьте (evt. Граф);
}
```

`Обработчик событий AddItemToCart`является основным компонентом тестирования этого теста, и так как как StateData и event построены вручную, разработчикам легко создавать сценарии, которые необходимо тестировать по мере необходимости.Нет необходимости строить что-то особенное.

Теперь, до тех пор, как`Обработчик событий AddItemToCart`Восстановите код прокомментировали и перезахоите модульный тест.Модульные тесты проходят.ОШИБКИ ТАКЖЕ ЕСТЕСТВЕННО ИСПРАВЛЕНЫ.

Конечно, есть еще один модульный тест сценария удаления выше, что не удается.Разработчики могут решить эту проблему, следуя описанным выше идеям «точка разрыва» и «модульный тест».

## Данные сохранились.

Вы можете попробовать перезапустить сервер Backend и Веб, и вы обнаружите, что данные, над которыми вы работали раньше, были сохраняются.

Мы рассмотрим его дальше в более поздней главе.

## Сводка

В этой статье мы имеем предварительное понимание того, как создать базовую структуру проекта для реализации простого сценария корзины.

Здесь много чего у нас нет подробного описания.：Структура проекта, развертывание, настойчивость и многое другое.Вы можете прочитать далее, чтобы узнать больше.
